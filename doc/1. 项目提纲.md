# 1. myos项目介绍

1. 首先是工具链的配置
   1. 目标平台是intel-i686架构的处理器
   2. 工具链：gcc  i686-elf交叉编译器、gdb 、qemu(模拟i386处理器环境)、grub(用于multiboot)、make(用于项目构建)、git(用于版本管理)
2. multiboot段编写
   1. 原理：编写multiboot header，bootloader读到boot loader header 说明我们内核符合multiboot stander，会将跳转到_start 函数，应该是gcc指定的内核起始函数，在\_start中跳转到kernel_main函数
3. 编译链接
   1. 编写链接脚本，将**.multiboot section**，.text section，.data section，.bss section按顺序加载到1mb内存空间处

## 1.1 设备管理

1. 屏幕输出实现+格式化输出函数
   1. 普通字符输出使用的是VGA的直接内存访问，内核只需要将数据写到0xb8000位置，由VGA的MDA控制器将数据写到对应寄存器
   2. 游标移动，直接访cursor对应端口的控制和数据寄存器
   3. 格式化输入输出使用屏幕输出提供的接口对格式字符串进行解析(va_start、va_end宏)，然后输出
2. 中断向量的的设置
   1. 0-31	软中断
   2. 0x8-0xF、 0x70-0x78 映射到IRQ，硬中断
   3. 这个内核中只使用了3个：0时钟、1键盘、14pagefault
   4. 中断处理模块编写了一个注册和分发函数，给其余模块来注册中断处理函数和以及在中断发生时调用对应的中断处理函数
3. 键盘输入，时钟
   1. 键盘中断处理函数中，读取端口0x60来得到scancode，然后根据scancode映射到对应的字符，然后输出
   2. 时钟中断

## 1.2 内存管理

![mem_layout](C:\Users\65796\Desktop\mem_layout.png)

1. 物理内存
   1. 使用位图管理空闲帧
2. 虚拟内存
   1. 创建内核页表，将内核已经使用的空间进行Identical mapping
   2. 映射堆区，起始地址为0xc000000,大小1MB
3. 内存分配
   1. 没有创建堆之前使用placement 分配方法
   2. 之后使用堆进行分配
4. 堆管理算法
   1. 类似C语言malloc分配内存方法，每内存块分三个部分header，data，footer，header和footer可以相互找到，整个堆作为一个块
   2. 使用一个**有序数组管理当heap中的空闲内存块**
   3. 分配：从heap的有序数组中找到符合条件的最小的内存块，返回这里面可能还包括需要对齐的内存，若分配完之后还有剩余空间，则创建一个新的块插入到这个有序数组中。当没有满足条件的空间时，申请虚拟空间，然后进行物理空间映射
   4. 回收：释放对应的堆空间之后，进行回收主要进行向左和向右合并

## 1.3 文件系统

1. 虚拟文件系统
   1. 使用node结构表示磁盘上的文件、目录、硬件设备，每个node都由对应的文件系统实现的回调函数open、read、write
   2. 使用dirent结构表示目录项，其中由该目录项对应文件的名称以及对应的inode号
   3. 实现统一的VFS结构函数，接口函数中其实是调用对应node的回调函数
2. 初始内存文件系统
   1. 介绍起始内存文件系统的格式
   2. 加载方式：配置grub启动文件，将initrd作为一个模块加载进来，grub会将multiboot信息的指针作为参数传递内kernel_main函数，然后我们可以从中访问到对应模块地址，然后根据文件格式构造出来对应的节点
   3. 实现具体的VFS接口



## 1.4 进程管理

	1. 由于没有实现user mode，当前任务只是内核级进程
	1. 由于GRUB加载时将栈位置设置为比较低的位置，而这个块虚拟内存是所有进程共享的，而每个进程都因该有自己的栈空间，所以我在初始化第一个进程时将栈的位置拷贝到heap之上，并且x86中需要用ebp来访问栈中变量，所以需要遍历拷贝过来的栈，当其位置存储的值指向[old_tack_pointer, old_esp]时将其偏移(有bug，会将其他在这个范围中断值也会更改)
	1. 进程间内存拷贝，根据页表找到两个进程的物理地址，调用汇编编写的copy_page，其中先禁止分页，拷贝完之后打开分页
	1. 进程管理使用进程链表read_queue, 连接就绪队列，在时钟中断进行进程的切换
